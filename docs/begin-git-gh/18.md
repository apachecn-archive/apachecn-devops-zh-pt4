# 18.常见的 Git 问题

自从我们的第一个 Git 命令以来，我们已经取得了很大的进步！我们已经了解了很多关于基本和高级 Git 特性以及何时使用它们的知识。但是因为我们只是人类，所以在我们的 Git 之旅中我们会面临很多问题。大多数这些问题都是由于疏忽造成的，所以意识到它们的存在就是朝着避免它们前进了一大步。但是如果你仍然碰到他们，这里有最好的解决方案！

## 贮藏室ˌ仓库

存储库是您 Git 体验的支柱；一切都在那里开始和结束。很难把事情搞砸，但是万一有不好的事情发生，这里有一些建议。

### 重新开始

这是本章中最激进的“解决方案”，我希望你永远不要使用它。这个解决方案基本上是删除一切，重新开始！只有当您有一个远程存储库，并且出于某种原因想要删除您的本地存储库时，这才应该是一个选项。这样做的原因包括

*   更换工作电脑

*   硬盘中不可读的扇区

*   中不可恢复的错误。git”目录

要重新开始，您只需要用 git clone 命令克隆远程存储库:

```
$ git clone <repository_location>

```

存储库位置是到您的远程存储库的 HTTPS 或 SSH 链接；您可以在您的 GitHub 项目页面上找到它。

克隆与初始化存储库的效果相同，但是有一个很大的好处:所有的历史和提交都将被复制到新的本地存储库中。你不再需要精确的原始链接。

### 改变原点

在正常情况下，您会希望在整个开发过程中保持远程存储库的 URL 不变。但是在某些情况下有必要改变它:

*   在 HTTPS 和 SSH 链接之间切换

*   将存储库转移到另一台主机

*   添加用于发布或测试的专用存储库

首先，让我们获得更多关于我们当前遥控器的信息。为此，使用带有“-v”选项的 git remote 命令。

```
$ git remote -v

```

这会给你一个当前遥控器的列表，如图 [18-1](#Fig1) 所示。

![../images/484631_1_En_18_Chapter/484631_1_En_18_Fig1_HTML.jpg](../images/484631_1_En_18_Chapter/484631_1_En_18_Fig1_HTML.jpg)

图 18-1

当前遥控器列表

这里，我们只有一个指向 GitHub HTTPS 链接的远程“起点”。要修改此链接，您需要使用 set-url 子命令:

```
$ git remote set-url <remote_name> <remote_url>

```

例如，如果我想切换到 SSH 而不是 HTTPS 来访问 GitHub，我会执行

```
$ git remote set-url origin git@github.com:mtsitoara/todo-list.git

```

这样做将允许我在不提供用户名和密码的情况下在 GitHub 之间进行推/拉操作。认证将通过两组密钥来完成:一个我保存在本地计算机上的私钥和一个我必须上传到 GitHub 的公钥。如果您对使用 SSH 进行身份验证感兴趣，请根据您的操作系统( [`https://help.github.com/en/articles/which-remote-url-should-i-use`](https://help.github.com/en/articles/which-remote-url-should-i-use) )前往 GitHub 帮助获取更多信息。如果您决定继续使用 HTTPS，但要缓存什么作为密码，这样您就不必总是键入密码，您可以使用凭据帮助器。同样，GitHub 帮助上有更多关于这个的信息，这取决于你的操作系统( [`https://help.github.com/en/articles/caching-your-github-password-in-git`](https://help.github.com/en/articles/caching-your-github-password-in-git) )。

### 警告

如果您更改了您的远程名称，不要忘记为每个推拉动作使用新名称。

## 工作目录

您将花费大部分时间在工作目录上，这里也没有太多东西可以破坏。

### Git diff 为空

这种情况经常出现，但并不危险。有时，您做了很多更改，并希望检查这些更改。但是当运行 git diff 时，结果是空的。别慌！Git diff 只显示修改过的文件，所以如果你的文件是暂存的，你不会在那里看到它。要查看对暂存文件所做的更改，您必须运行:

```
$ git diff --staged

```

### 小费

在审查变更时，使用 GUI 工具会给你很大的帮助。

### 撤消对文件的更改

当您使用 Git 时，这将会经常出现。有时，您只想将文件恢复到其以前的状态，而不必签出整个提交，然后复制粘贴代码。我们已经在前面看到过这个命令:

```
$ git checkout <commit_name> -- <file_name>

```

该命令将按照提交时的样子签出文件，因此将更改您的工作目录。小心不要丢失任何未提交的更改！

## 承诺

当你试图提交你当前的项目时，大多数问题都会出现。但是不要担心，对于这类问题总有一个简单的解决方案。要考虑的最重要的事情是:你正在使用的命令是破坏性的吗？像 reset 或 check out 这样的命令会改变你的工作目录，所以在执行它们之前，请确保你知道你在做什么。

### 提交时出错

这是 Git 中的一个基本错误。在您提交您的努力工作之后，您有时会注意到一个小小的语法错误出现在您的提交消息中，或者您忘记上传一个文件。这些问题的解决方案是修改提交，这意味着您将取消立即提交并进行新的提交。命令很简单:

```
$ git commit --amend

```

提交名称将会改变，因为您基本上是在改变它的内容。这就是为什么您不应该修改已经推送到远程分支的提交，尤其是如果有人在那个分支上工作。这是在改写历史，你绝对不应该这么做。

也就是说，如果您已经提交了提交，并且单独在分支上，您可以修改提交并尝试再次提交。但是由于 commit 的名字改变了，Git 不会允许你不战而降地改变历史。您必须清除远程分支上的所有历史记录，并用您的历史记录替换，这意味着您将覆盖远程分支上的所有内容。这就是为什么如果你不是单独在一个分支上，就不应该修改提交。要使用修改的提交来推送分支，您需要强制它。

```
$ git push <remote_name> <branch_name> -f

```

“-f”选项强制 Git 覆盖远程分支上的所有内容，并用您当前的分支历史替换它。

### 警告

在别人工作的地方重写历史是非常粗鲁和自私的。别这么做。

只有当您想要修改提交消息或添加/删除文件时，才应该使用修改提交。不要修改提交更改代码。

### 撤消提交

如果您提交了一个分支，但随后意识到它是错误的，您可以撤销它，但只有当您没有推送到远程分支时。

这个命令很简单但是很危险:它是 reset 命令。但是与清除所有内容的“硬”重置相反，“软”重置是撤销提交但保留更改所必需的。

```
$ git reset HEAD~ --soft

```

然后提交将会消失，留给您一些选项来隐藏更改并将它们应用到另一个分支。

同样，这是在重写历史，如果您已经推送到一个远程分支，就不应该使用它。

## 分支

您将需要与分支机构合作很多，以优化工作流程。当处理一个新的特性或者 bug 时，你的第一反应应该是创建一个分支。但是你对分支越熟悉，你就越有可能忘记一个可能导致问题的小细节。以下是您在使用 Git 时会遇到的最常见的问题。

### 分离头

HEAD 是对当前签出提交的引用，意味着您将创建的任何未来提交的父提交。通常，HEAD 指向当前分支的最后一次提交；并且所有将来的分支和提交都将它作为父级。

当您签出分支时，头将在分支的最后一次提交之间来回移动。但是当你检查一个特定的提交时，你进入了一个被称为“分离头”的状态，这意味着你将创建的任何东西都不会被附加到任何东西上。在那种状态下尝试提交是没有用的，因为任何改变都会丢失。

Git 会告诉你什么时候你处于那种状态(如图 [18-2](#Fig2) )，这样你就不会不知不觉地处于那种状态。

![../images/484631_1_En_18_Chapter/484631_1_En_18_Fig2_HTML.jpg](../images/484631_1_En_18_Chapter/484631_1_En_18_Fig2_HTML.jpg)

图 18-2

检查提交

因此，只有在软件上测试某些东西时，才需要检查提交。但是，如果您希望保留您打算进行的提交，您可以从该特定提交创建一个分支。该命令与从另一个分支创建分支相同:

```
$ git checkout -b <branch_name>

```

### 在错误的分支工作

这种情况经常发生。情况通常是这样的:你接到一个任务，你是如此渴望完成它，以至于你立即开始编码。当你注意到你一直在主分支工作时，你已经工作了一个小时了！别担心，解决这个问题非常简单。

如果您在错误的分支上修改了一些文件，您可以直接创建一个新的分支(并将其签出)以将当前的更改带到那里。又是同一个命令:

```
$ git checkout -b <branch_name>

```

这将使用您当前的更改创建一个新的分支，并将其签出。然后，您可以暂存修改后的文件并提交项目。

然而，如果您已经将分支推送到远程存储库，这将不起作用；历史就是历史，不要改变。解决这个问题的唯一方法是改变你所做的承诺，并且带着这种耻辱生活一辈子。

### 赶上母分公司

当您从另一个分支(通常是主分支)创建一个分支时，它们的历史不再链接，因此在一个分支中发生的事情不会影响到另一个分支。这意味着当您在您的分支上工作时，其他人可以在基础分支上提交；并且这些提交对您的分支不可用。

如果您仍然在您的分支上工作，但是对基础分支上的那些新提交感兴趣，您必须首先有一个干净的盘子，这意味着您必须提交您的项目(或者隐藏您当前的变更)。

然后，您必须签出父分支，提取新的提交，然后回到您的分支。

```
$ git checkout master
$ git pull origin master
$ git checkout <branch_name>

```

安全地放在您的本地分支上，然后您可以赶上父分支。概念很简单:Git 将取出您当前的提交，并从父分支的顶端创建新的分支；您的提交将应用到您的新分支。这就像您从主分支的最新提交中创建一个分支。该命令称为 rebase。

```
$ git rebase master

```

master 上的提交可能会在您的分支中引入冲突，所以要做好动手的准备。这些合并冲突的解决与我们之前看到的一样:打开每个冲突的文件，选择您想要保留的代码；然后你就可以上演它们并提交。

你可以在图 [18-3](#Fig3) 中找到一个 rebase 冲突的例子，其中 master 和 test_branch 上的提交都修改了 README.md。

![../images/484631_1_En_18_Chapter/484631_1_En_18_Fig3_HTML.jpg](../images/484631_1_En_18_Chapter/484631_1_En_18_Fig3_HTML.jpg)

图 18-3

重设基础期间合并冲突

如您所见，这几乎与任何合并冲突完全一样；分辨率是一样的:

```
$ git add <conflicted_files>
$ git rebase --continue

```

同样，如果你对冲突没有足够的勇气，你可以中止重置基础并回到初始状态。

```
$ git rebase --abort

```

如果你在一个分支上工作了很长时间，不时地调整基础是个好主意，这样你就不会离母分支太远。当然，您可能会面临合并冲突，但是您的变更越大，这些冲突就越有可能出现。如果你因为害怕冲突而延迟重定基础，你只会让自己失败，因为当你试图合并分支时，这些冲突会再次出现。不时地用 rebase 处理小的冲突比在合并时不得不同时合并许多冲突的文件要好。

### 分支已经分叉

如果您使用的是糟糕的 Git 工作流，就会发生这种情况。正如我们前面所说的，您应该在您自己的分支上工作来解决问题，因为多个人在同一个分支上工作是导致灾难的最佳方法。

我们说，当您由于历史更改而无法再推进到远程分支时，两个分支就会分叉。当您在本地分支上提交时，会发生这种情况，但是其他人已经在您之前在远程分支上提交了他们的提交。到了推的时候，Git 不会让你这么做，因为远程分支的最后一次提交不属于本地历史。您将得到如图 [18-4](#Fig4) 所示的错误。

![../images/484631_1_En_18_Chapter/484631_1_En_18_Fig4_HTML.jpg](../images/484631_1_En_18_Chapter/484631_1_En_18_Fig4_HTML.jpg)

图 18-4

拒绝的更改

下面是最明智的解决方案:提取远程分支的提交并合并您的更改。然后，您将在您的历史中记录他们的更改(在解决最终的合并冲突之后),并可以在之后进行推送。

```
$ git pull origin <branch_name>
$ git push origin <branch_name>

```

这会给你一个难看的历史日志，但是至少所有的提交都被保存了。这方面的一个例子如图 [18-5](#Fig5) 所示。

![../images/484631_1_En_18_Chapter/484631_1_En_18_Fig5_HTML.jpg](../images/484631_1_En_18_Chapter/484631_1_En_18_Fig5_HTML.jpg)

图 18-5

合并本地和远程分支

另一个解决方案更加残酷:覆盖远程分支上的所有内容，并用您的历史替换它的历史。为此，您必须使用“强制”选项进行推送。

```
$ git push origin <branch_name> -f

```

这导致提交失败和打斗；永远不要这样做。

同样，如果你使用一个好的 Git 和 GitHub 工作流，这不应该发生。

## 摘要

这一章是为了在面对常见的 Git 问题时给你指出正确的解决方案。当然，你会发现新的、更难的问题，但这是一个好的开始。要记住的主要事情是，在做任何事情之前，尤其是承诺之前，总是要检查你在哪里。

但是如果你使用通用的 Git 和 GitHub 工作流，这些问题根本不应该出现。所以，让我们在下一章重新发现这一点。我们已经在前面的章节中谈到了这一点，但是在您看到了所有最常用的 Git 和 GitHub 特性之后，是时候回顾一下了。