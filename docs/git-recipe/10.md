第十章

![image](images/frontdot.jpg)

远程存储库和同步

所有 VCS 系统背后的内在原因是使一组开发人员之间的协作尽可能无缝。最后，我们已经到了可以讨论如何使用 git 进行小组工作的时候了。我们将从最简单的设置开始，所有的存储库都可以通过本地存储获得。

首先你必须学会如何使用遥控器。我们将在一个菜谱中讨论这个问题，这个菜谱将向您展示当您克隆一个存储库时会发生什么。然后，我们将深入介绍两个或更多开发人员如何合作的分步方法。我们将考虑两种重要情况:

*   第一种:所有成员共享和访问一个空存储库
*   第二种:两个开发者直接合作，不需要任何额外的存储库

您可以将第一个视为集中式客户机/服务器解决方案，而将另一个视为对等解决方案。Git 是一个分布式系统，允许您混合两种方法。

从中央存储库下载新贡献的最简单方法是使用`$ git pull`命令。当使用默认设置时，这会导致项目的历史非常复杂。我会告诉你什么时候，为什么你会遇到麻烦。这将引导我们改进食谱，永远为你提供一个干净的历史。

我在配方 5-2 中提到的不同类型分支的主题将再次出现。这一次，我们将坚持到底。您将了解关于远程分支机构、本地跟踪分支机构和远程跟踪分支机构的所有信息。我不仅将向您展示如何列出、创建、销毁和同步它们，还将展示不同的命令，如`$ git commit`和`$ git fetch`，如何影响它们的状态。本章将让您对远程分支机构、远程跟踪分支机构和本地跟踪分支机构有一个全面而完整的了解。通过获得这些技能，你将准备好加入任何使用 git 的团队。

10-1.手动克隆

问题

你想对克隆有更深入的了解。实现这一点的一种方法是手动克隆一个存储库。您想要执行一个手动克隆，在这个过程中，每一个内部 git 操作，比如新存储库的初始化和从远端获取修订，都是用一个更专门的命令来执行的。继续这个配方克隆`https://github.com/creationix/js-git`库。js-git 项目是 git 的初步 JavaScript 实现。

解决办法

使用以下内容创建一个新目录:

```
$ cd git-recipes
$ mkdir 10-01
$ cd 10-01
```

然后按照以下步骤操作:

1.  使用`$ git init`初始化新的存储库
2.  添加远端的网址:`$ git remote add origin` `https://github.com/creationix/js-git.git`
3.  从远端获取 git 数据库和远程跟踪分支:`$ git fetch --no-tags origin master:refs/remotes/origin/master`
4.  创建一个本地的`master`分支，它将指向与`origin/master`远程跟踪分支相同的版本:`$ git rev-parse origin/master > .git/refs/heads/master`
5.  用`$ git branch --set-upstream-to=origin/master`设置`master`分支为远程跟踪分支`origin/master`的本地跟踪分支
6.  将默认分支的信息存储在本地的远程存储库中:`$ git symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/master`
7.  签出工作目录中的文件:`$ git checkout`

它是如何工作的

这个食谱揭开了克隆操作的神秘面纱。它将克隆分为:

*   初始化
*   遥控器的定义
*   下载 git 数据库和远程跟踪分支
*   创建适当的分支

Git 启动一个克隆，用`$ git init`命令初始化一个新的空存储库。在这个命令之后，存储库是空的——它不包含任何分支。`$ git branch`的输出为空。

要从外部来源复制修订，我们需要一个 URL。这个 URL 是用`$ remote add [alias] [URL]`命令设置的。第一个参数是短别名；第二个参数是一个 URL。一旦你定义了一个远程 `origin`用:

```
$ git remote add origin https://github.com/creationix/jz-git.git
```

您可以使用短别名`origin`来代替完整的 URL。命令:

```
$ git fetch --no-tags origin master:refs/remotes/origin/master
```

相当于:

```
$ git fetch --no-tags https://github.com/creationix/js-git.git master:refs/remotes/origin/master
```

可以用`$ git remote`命令列出遥控器。默认情况下，该命令打印定义的别名。附加参数`-v`打开详细输出。命令`$ git remote -v`打印所有别名的名称和 URL。可以使用`$ git remote rm [alias]`命令移除遥控器。

所有遥控器都存储在`.git/config`文件中。当您执行:`$ git remote add foo` `https://example.comnet/bar.git`时，git 会在`.git/config`文件中添加以下条目:

```
[remote "foo"]
    url = https://example.comnet/bar.git
    fetch = +refs/heads/*:refs/remotes/foo/*
```

该行:

```
url = https://example.comnet/bar.git
```

存储 URL。第二行:

```
fetch = +refs/heads/*:refs/remotes/foo/*
```

定义了所谓的 *refspec* 。Refspec 指定了远程分支(即远程存储库中的分支)映射到远程跟踪分支(即存储在`refs/remotes/foo`目录中的本地分支)的方式。远程存储库在其`.git/refs/heads`目录中包含分支。我们希望以这样一种方式复制它们，使得它们不会与我们在`.git/refs/heads`本地存储的普通本地分支相冲突。因此，我们将远程跟踪分支放在一个名为`.git/refs/remotes/foo`的单独目录中。只要用于命名远程的别名是唯一的，我们就可以确保来自不同远程的分支不会相互冲突，也不会与我们的本地分支冲突。

您可以治疗:

```
fetch = +refs/heads/*:refs/remotes/foo/*
```

两个目录之间的 1:1 映射:一个在远程存储库中，另一个在本地存储库中。上面说明了在远端的`.git/refs/heads`目录中别名为`foo`的所有文件都被映射到本地名为`.git/refs/remotes/foo`的目录中。该映射在`$ git fetch`和`$ git push`操作期间使用。放置在 refspec 最开始的字符`+`允许您推送修订，这些修订将覆盖存储在远程存储库中的历史。

值得注意的是，除了存储在`.git/config`文件的`[remote "foo"]`部分中的配置之外，两个存储库之间没有其他依赖关系。遥控器的名称只是一个别名，使您的命令更短。您可以使用遥控器的名称，而不是键入完整的 URL。此外，远程别名只存储在本地存储库中。远程终端不会在其配置中存储任何有人使用其 URL 的信息。

![image](images/sq.jpg) **提示** Origin 是 git 在克隆操作期间为远程存储库使用的标准名称。这没有什么神奇的:你可以用`$ git remote rm origin`删除一个原始遥控器。你可以用`$ git remote add origin [URL]`创建一个新的原点遥控器。

一旦定义了远程，我们就可以将 git 数据库从远程复制到本地存储库中。这是通过`$ git fetch --no-tags origin master:refs/remotes/origin/master`命令完成的。在这个命令之后，存储库包含一个远程跟踪分支。命令`$ git branch -a -vv`输出类似于:

```
remotes/origin/master 60478cc Bump version to 0.3.1
```

参数`--no-tags` 确保包含在远程储存库中的标签不被复制。下一个参数`origin`给出了我们想要从中复制修订的遥控器的名称。最后一个参数`master:refs/remotes/origin/master`是一个 refspec。它由冒号分隔的两个名称组成:

*   `master`—远程存储库中的远程分支的名称，别名为`origin`
*   `refs/remotes/origin/master`—远程跟踪分支的名称(它是本地存储库中的本地分支)

refspec 确保远程`master`分支将被复制到本地`.git/refs/remotes/origin/master`文件中。在 fetch 命令之后，本地存储库中的`.git/objects`目录包含了从远程存储库中复制的对象。您应该注意到，`$ git fetch`命令创建了一个本地文件`.git/refs/remotes/origin/master`。这是远程分支的副本。副本作为远程跟踪分支存储在本地存储库中。回到配方 5-2，我强调了远程跟踪分支是本地分支。这就是远程跟踪分支是如何创建的:它们在`$ git fetch`命令之后出现在您的存储库中。您可以通过在`$ git fetch`之后立即发出的`$ git branch -a -vv`命令来验证这一点。即使你用`$ git branch -d -r`命令删除了一个远程跟踪分支，它也会在下一个`$ git fetch`命令后被重新创建。

下一步就是成立当地的`master`分公司。正如您已经知道的，一个普通的本地分支只是一个存储适当的 SHA-1 名称的文本文件。我们希望我们的分支指向与获取操作期间创建的`.git/refs/remotes/origin/master`分支相同的修订。存放在`.git/refs/remotes/origin/master`的分支可以简称为`origin/master`。你如何找到由一些象征性的参考`origin/master`所指向的修订版的 SHA-1 名字？为此，我们可以使用$ `git rev-parse`命令。运行命令`$ git rev-parse origin/master`。它将打印出由`.git/refs/remotes/origin/master`分支指向的修订的 SHA-1 名称。要创建一个指向相同版本的普通本地分支，将 SHA-1 存储在一个文本文件中就足够了:

```
$ git rev-parse origin/master > .git/refs/heads/master
```

![image](images/sq.jpg) **提示**`$ git rev-parse origin/master > .git/refs/heads/master`命令的结果也可以用`$ cp .git/refs/remotes/origin/master .git/refs/heads/master`命令来实现。

上面的命令创建了一个名为`master`的普通本地分支。`$ git branch -a -vv`命令的输出应该类似于:

```
* master                60478cc Bump version to 0.3.1
  remotes/origin/master 60478cc Bump version to 0.3.1
```

现在我们把一个普通的本地分支`master`变成一个本地跟踪分支，用于远程跟踪`origin/master`分支。这通过以下方式完成:

```
$ git branch --set-upstream-to=origin/master
```

在此之后，`$ git branch -a -vv`版画:

```
* master                60478cc [origin/master] Bump version to 0.3.1
remotes/origin/master 60478cc Bump version to 0.3.1
```

感谢第一线的`[origin/master]`，我们知道`master`是远程跟踪分支`origin/master`的本地跟踪分支。

命令`$ branch --set-upstream-to=origin/master`在`.git/config`文件中创建以下条目:

```
[branch "master"]
    remote = origin
    merge = refs/heads/master
```

这表示您的本地`master`分支被设置为跟踪存储在由`origin` URL 指向的存储库中的`refs/heads/master`中的远程分支。通过对本地和远程分支使用不同名称的示例，更容易理解上面命令的含义。假设您的本地存储库包含一个名为`foo`的普通本地分支。您希望`foo`分支跟踪远程存储库中的`bar`分支。如果您发出以下命令:

```
$ git branch --set-upstream-to=origin/bar foo
```

然后将创建以下配置条目:

```
[branch "foo"]
    remote = origin
    merge = refs/heads/bar
```

由`origin`指向的远程存储库包含一个文件`.git/refs/heads/bar`。这是`bar`的远程分支。本地存储库包含`.git/refs/remotes/origin/bar`和`.git/refs/heads/foo`。第一文件`.git/refs/remotes/origin/bar`是远程跟踪分支，第二文件`.git/refs/heads/foo`是本地跟踪分支。本地跟踪支路`foo`与远程跟踪支路`origin/bar`相连。

![image](images/sq.jpg) **提示**你也可以用`$ git branch master origin/master`命令创建指向`origin/master`的`master`分支。我避免了上面的命令，因为它不仅创建了一个本地的`master`分支，还设置了跟踪。我更喜欢把两项业务分开。因此我用`$ git rev-parse`和`$ git branch --set-upstream-to`来分别执行这两个动作。

这个过程的最后一步是在本地远程存储库中存储关于默认分支的信息:

```
$ git symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/master
```

该命令将创建一个本地文件`.git/refs/remotes/origin/HEAD`。该文件将包含一个指向`refs/remotes/origin/master`的符号引用。这就是我们如何知道在远端哪个分支被认为是默认的。

Git 允许使用`$ git config`命令直接操作其配置。因此在`foo`分支发出的命令`$ git branch --set-upstream-to=origin/bar`相当于两个命令:

```
$ git config branch.foo.remote origin
$ git config branch.foo.merge refs/heads/bar
```

使用一个额外的`--unset`参数你也可以取消设置任意选项。在配方 10-5 中，我们将使用:

```
$ git config --unset branch.foo.remote
$ git config --unset branch.foo.merge
```

取消跟踪。

10-2.与中央存储库 合作

问题

您希望使用一个中央存储库来模拟两个开发人员 John 和 Sarah 的合作。在这种情况下，协作 将由三个库组织:

*   第一个开发者的非裸存储库
*   `10-02/sarahs-repo`—第二个开发者的非裸库
*   一个用来同步约翰和莎拉工作的空仓库

在这个配方中，两个开发者将只使用`master`分支 来工作。您希望分析在以下情况下会发生什么:

*   每个开发人员在`master`分支继续他或她的工作
*   一个开发人员将他或她的修改发送到共享的回购协议中
*   另一个开发人员获取新的版本

![image](images/sq.jpg) **提示**这个菜谱展示了如何围绕一个中心库来组织团队的工作。这个工作流程类似于集中式系统使用的客户端/服务器方法，如 CVS 或 SVN。

解决办法

使用以下内容创建新目录:

```
$ cd git-recipes
$ mkdir 10-02
$ cd 10-02
```

工作由开发人员之一初始化 。我们假设是约翰开始了整个项目:

```
# the command issued in git-recipes/10-02 directory
$ git init --bare shared-repo
```

这个存储库将用于同步 John 和 Sarah 的工作。

接下来，约翰创建了自己的知识库:

```
# john's commands in git-recipes/10-02 directory
$ git init johns-repo
```

然后他设置他的个人数据并定义`origin`遥控器T2:

```
# john's commands
$ cd johns-repo
$ git config --local user.name john
$ git config --local user.email john@example.net
$ git remote add origin ../shared-repo
```

这两个库现在看起来像[图 10-1](#Fig1) 。图中未示出元信息`user.name`、`user.email`和`remote.origin`。

![9781430261032_Fig10-01.jpg](images/9781430261032_Fig10-01.jpg)

[图 10-1](#_Fig1) 。初始化后的两个存储库

然后，John 在他的私有存储库 中创建了一些修订:

```
# john's command
$ git simple-commit a1 a2 a3
```

现在，John 的存储库中包含一个名为`master`的普通分支。`$ git branch -a -vv`的输出类似于:

```
* master dc30648 a3
```

存储库看起来像图 10-2 。

![9781430261032_Fig10-02.jpg](images/9781430261032_Fig10-02.jpg)

[图 10-2](#_Fig2) 。约翰的 a1、a2、a3 提交后的储存库状态T3】

约翰将他的`a1`、`a2`和`a3`修订发送到`shared-repo`存储库 中:

```
# john's command
$ git push -u origin master
```

该命令在远程`shared-repo`存储库中创建一个新的分支。新的远程分支被命名为`master`。由于有了`-u`参数，上面的命令在`johns-repo`中创建了一个远程跟踪分支`origin/master`。您可以使用`$ git branch -a -vv`命令进行验证。输出将类似于:

```
* master                dc30648 [origin/master] a3
  remotes/origin/master dc30648 a3
```

如您所见，John 的存储库包含一个本地跟踪分支`master`和一个远程跟踪分支`origin/master`。我们可以说，`-u`参数将名为`master`的普通本地分支转换为本地跟踪分支。存储库现在看起来像[图 10-3](#Fig3) 。

![9781430261032_Fig10-03.jpg](images/9781430261032_Fig10-03.jpg)

[图 10-3](#_Fig3) 。约翰发布的$ git push -u origin master 的效果

接下来莎拉加入了这个项目。她克隆了:

```
# sarah's commands
# executed in git-recipes/10-02
$ git clone shared-repo sarahs-repo
$ cd sarahs-repo
```

因为莎拉使用了`$ git clone`命令T4，她的`master`分支被设置为跟踪远程`master`分支。这三个存储库现在看起来如图 10-4 所示。

![9781430261032_Fig10-04.jpg](images/9781430261032_Fig10-04.jpg)

[图 10-4](#_Fig4) 。莎拉发行的$ git 克隆共享回购 sarahs-repo 的效果

现在轮到莎拉为这个项目做贡献了。她创建了两个版本`b1`和`b2`:

```
# sarah's command
$ git simple-commit b1 b2
```

存储库现在看起来像图 10-5 。

![9781430261032_Fig10-05.jpg](images/9781430261032_Fig10-05.jpg)

[图 10-5](#_Fig5) 。在 Sara 已经创建了 b1 和 b2 提交T3 之后仓库的状态

下一步，Sarah 将她的修订发送给`shared-repo`,内容如下:

```
# sarah's command
$ git push origin master
```

注意 Sarah 不需要使用`-u`。她用`$ git clone`命令初始化了她的存储库，因此自动初始化了对`master`分支的跟踪。John 用`$ git init`初始化了他的存储库。这就是为什么他第一次推的时候需要用`-u`。Sarah 的 push 命令的结果如[图 10-6](#Fig6) 所示。

![9781430261032_Fig10-06.jpg](images/9781430261032_Fig10-06.jpg)

[图 10-6](#_Fig6) 。萨拉的$ git push -u origin master 命令之后的仓库

现在轮到约翰下载莎拉的修改。他跑着说:

```
# john's command
$ git pull origin master
```

这导致了图 10-7 中[所示的状态。](#Fig7)

![9781430261032_Fig10-07.jpg](images/9781430261032_Fig10-07.jpg)

[图 10-7](#_Fig7) 。后一库约翰的$ git 拉原点主控命令T3】

上述模式可以重复任意多次。在约翰和莎拉的主分支分开之前，没有什么特别的事情发生。我们来分析一个这样的案例。

约翰和莎拉的作品

这一次，John 和 Sarah 都在他们的存储库中独立工作。约翰创建修订版`a4`和`a5`，而莎拉创建修订版`b3`:

```
# john's command
$ git simple-commit a4 a5

# sarah's command
$ git simple-commit b3
```

图 10-8 中描述了您将获得的存储库。

![9781430261032_Fig10-08.jpg](images/9781430261032_Fig10-08.jpg)

[图 10-8](#_Fig8) 。约翰和莎拉的分支分叉的存储库

现在约翰和莎拉都想把他们的修改推进`shared-repo`。我们假设 Sarah 是第一个执行`$ git push`命令的人。之后:

```
# sarah's command
$ git push origin master
```

存储库看起来像[图 10-9](#Fig9) 。

![9781430261032_Fig10-09.jpg](images/9781430261032_Fig10-09.jpg)

[图 10-9](#_Fig9) 。Sarah 成功的$ git push origin master 命令之后的存储库

现在约翰想把他的作品寄给`shared-repo`:

```
# john's command
$ git push origin master
```

Git 拒绝提交，因为`johns-repo`已经过时。上述命令的输出包含以下消息:

```
! [rejected]        master -> master (fetch first)
```

Git 通知 John，他的推送被拒绝，他必须首先获取缺失的修订。为了更新他的本地`master`分支，John 运行以下命令:

```
# john's command
$ git pull origin master
```

pull 命令获取 Sarah 的`b3`修订版并执行合并操作。现在存储库看起来像[图 10-10](#Fig10) 。

![9781430261032_Fig10-10.jpg](images/9781430261032_Fig10-10.jpg)

[图 10-10](#_Fig10) 。John 的$ git pull origin master 命令之后的存储库

John 的`$ git pull origin master`命令使用 Sarah 的最新版本更新了他的存储库，因此 John 现在可以使用以下命令将他的工作推送到`shared-repo`:

```
# john's command
$ git push origin master
```

注意，John 不再需要参数`-u`了，因为跟踪已经被 John 对`$ git push -u`的第一次调用所定义。存储库看起来像[图 10-11](#Fig11) 。

![9781430261032_Fig10-11.jpg](images/9781430261032_Fig10-11.jpg)

[图 10-11](#_Fig11) 。John 成功的$ git push origin master 命令之后的存储库

最后，Sarah 使用以下方法完成了 John 的工作:

```
# sarah's command
$ git pull origin master
```

产生的储存库如图 10-12 所示。

![9781430261032_Fig10-12.jpg](images/9781430261032_Fig10-12.jpg)

[图 10-12](#_Fig12) 。配方 10-2 中存储库的最终状态

它是如何工作的

在我们深入研究用于更新三个存储库的命令之前，让我们从分析图 10-12 中[所示的所有三个存储库的内容开始。它们都包含完全相同的提交。您可以使用`$ git log`命令来验证这一点。进入`git-recipes/10-02/johns-repo`目录，运行下面的`$ git log`命令:](#Fig12)

```
$ cd git-recipes/10-02/johns-repo
$ git log --oneline
```

您将获得类似于清单 10-1 中所示的输出。

[***清单 10-1。***](#_list1) 图 10-12 中的[在 johns-repo 中执行的$ git log](#Fig12)-one line 的输出

```
515710e Merge branch 'master' of ../shared-repo
596e379 b3
5d11316 a5
2f46c63 a4
82d0a6b b2
6075835 b1
73e4416 a3
44fc529 a2
c8e56d1 a1
```

对 Sarah 的存储库重复类似的命令:

```
$ cd git-recipes/10-02/sarahs-repo
$ git log --oneline
```

上述命令将打印清单 10-2 中的输出。

[***清单 10-2。***](#_list2)$ git log 的输出-one line run in sarahs-repo from[图 10-12](#Fig12)

```
515710e Merge branch 'master' of ../shared-repo
596e379 b3
5d11316 a5
2f46c63 a4
82d0a6b b2
6075835 b1
73e4416 a3
44fc529 a2
c8e56d1 a1
```

尽管实际打印在屏幕上的 SHA-1 会有所不同，但您应该注意到两个输出是完全相同的。从[图 10-12](#Fig12) 中可以猜出`shared-repo`中执行的`$ git log`的输出:

```
$ cd git-recipes/10-02/shared-repo
$ git log --oneline
```

也会一模一样。存储在:`johns-repo/.git/objects`、`sarahs-repo/.git/objects`和`shared-repo/.git/objects`中的三个数据库包含完全相同的对象。这由以下事实来证明:在所有三个存储库中由`$ git log`返回的 SHA-1 名称是相同的。

换句话说，当您使用`$ git push`或`$ git pull`发送或接收修订时，git 会在存储库之间复制数据库条目。这与`$ git rebase`、`$ git cherry-pick`和`$ git commit --amend`命令相反。当您在本地存储库中工作时，没有复制现有修订的方法—您所能做的就是用新的 SHA-1 名称创建一个新的数据库对象。另一方面，在`$ git push`和`$ git pull`命令期间，修改被复制而不是重新提交。复制的对象与原始对象具有相同的 SHA-1。

在这个配方中，我们使用了两个命令来发送和接收远程存储库的修订:

*   `$ git push`—将修订从本地发送到远程
*   `$ git pull`—将修订从远程下载到本地，然后与适当的分支合并

这些命令带有两个参数:

```
$ git push origin master
$ git pull origin master
```

在这两种情况下，`origin`是远程的名称，而`master`是本地分支的名称。

第一个命令`$ git push origin master`，将本地分支发送到远程存储库。更准确地说，我们可以说该命令将丢失的修订从本地存储库发送到远程端，然后更新分支(远程分支和远程跟踪分支——我们将很快讨论这一点)。

当 John 对图 10-2 中[的仓库执行`$ git push origin master`时，首先 git 将三个版本`a1`、`a2`、`a3`从`johns-repo`的数据库复制到`shared-repo`的数据库，然后更新分支。](#Fig2)

默认情况下，git 将`$ git push`操作限制为快进情况。这意味着只有当远程分支可以快速推进您的工作时,`$ git push`才会成功。这是约翰将图 10-2 中的[状态变为图 10-3](#Fig2) 中的[状态的情况。图 10-2](#Fig3) 中[库`shared-repo`为空；因此它可以安全地接收三个提交`a1`、`a2`和`a3`。当 Sara 将存储库从图 10-5](#Fig2)[中的](#Fig5)更改为图 10-6 中的[所示的存储库时，也会发生同样的情况。图 10-5](#Fig6) 中[所示的库`shared-repo`包含了`a1`、`a2`和`a3`三个版本。不包含`sarahs-repo`中`a3`之前的`b1`和`b2`修订。`shared-repo`中的`master`分支可以用`b1`和`b2`版本快进，因此操作成功。](#Fig5)

[图 10-9](#Fig9) 所示的情况要复杂得多。共享存储库中的`master`分支 和 John 的存储库中的`master`分支已经分离。约翰的包含`a4`和`a5`，共享存储库包含`b3`。因此约翰在图 10-9 所示的[库中执行的`$ git push origin master`失败。Git 打印了 John 首先从远程存储库获取修订所需的信息。](#Fig9)

当与`-u`参数一起使用时，`$ git push`命令存储关于跟踪的信息。命令:

```
$ git push -u origin master
```

当约翰将他的`a1`、`a2`和`a3`修订版本推送到约翰的存储库中的远程跟踪分支`remotes/origin/master`时，由约翰执行。`master`分行被设置为`origin/master`分行的本地跟踪分行。只有在第一次调用`$ git push`时才需要这个参数。

该库中使用的新命令是`$ git pull origin master`。这个命令从`origin`指向的远程存储库中复制修订。修订从远程的`master`分支复制，然后与本地存储库中当前的`master`分支合并。如果操作可以作为快进执行，则不存在合并提交。这是将图 10-6[所示的状态变为图 10-7](#Fig6) 所示的状态。当本地和远程分支出现分歧时，该命令会生成一个合并提交。这就是为什么我们在清单 10-1 和 10-2 的顶部显示了合并提交。当您将图 10-9 所示的状态更改为图 10-10 所示的状态时，合并提交出现在`johns-repo`中。

提交如何影响跟踪分支

我们再次从 Sarah 的回购的角度分析跟踪分支如何在提交 期间改变。在`$ git clone shared-repo sarahs-repo`之后，仓库`shared-repo`和`sarahs-repo`看起来像[图 10-13](#Fig13) 。

![9781430261032_Fig10-13.jpg](images/9781430261032_Fig10-13.jpg)

[图 10-13](#_Fig13) 。克隆后立即共享回购和 sarahs 回购

我们从莎拉的角度来看这个情况。因此`sarahs-repo`是本地存储库，`shared-repo`是远程存储库，如图 10-13 中的[所示。该图显示了三种类型的分支:远程分支、本地跟踪分支和远程跟踪分支。Sarah 的存储库不包含任何普通的本地分支。当 Sarah 克隆存储库时，`$ git clone`命令会自动为她创建两个本地分支:`master`和`origin/master`。第一个是本地跟踪分支；第二个是远程跟踪分支。您可以使用`$ git branch -a -vv`命令验证这一点。输出将包含两行重要的内容:](#Fig13)

```
* master                36c7205 [origin/master] a3
  remotes/origin/master 36c7205 a3
```

第一行表示`master`是`origin/master`分支的本地跟踪分支。第二行表示`origin/master`是一个远程分支。

当 Sarah 用`$ git simple-commit b1 b2`提交时，她将她的`master`分支(即本地跟踪分支)向前移动。`$ git simple-commit b1 b2`后的分支状态如图[图 10-14](#Fig14) 所示。

![9781430261032_Fig10-14.jpg](images/9781430261032_Fig10-14.jpg)

[图 10-14](#_Fig14) 。在 Sarah-repo 中执行$ git simple-commit b1 b2 后分支的状态如图 10-13 所示

您可以使用`$ git log --oneline --decorate`命令来验证 Sarah 的存储库的状态。输出:

```
b019 (HEAD, master) b2
978f b1
66ad (origin/master, origin/HEAD) a3
91d5 a2
b189 a1
```

包含指向适当修订的标签`master`和`origin/master`。关于分支状态的简短信息也可以通过`$ git status -sb`命令获得。当在[图 10-14](#Fig14) 的`sarahs-repo`中执行时，该命令将产生如下输出:

```
## master...origin/master [ahead 2]
```

这将通知您，您的本地跟踪分支包含两个未包含在远程跟踪分支中的修订。换句话说:本地跟踪分支`master`比远程跟踪分支`origin/master`领先两个版本。

如您所见，提交操作仅向前移动本地跟踪分支。远程跟踪分支和远程分支保持不变。

推动如何影响跟踪分支

我们如何更新`shared-repo`中的远程分支主机和 Sarah 的存储库中的远程跟踪分支`origin/master`？这是在莎拉用`$ git push origin master`命令提交时完成的。该命令改变两个储存库的状态，如图[图 10-15](#Fig15) 所示。[图 10-15](#Fig15) 展示了在[图 10-14](#Fig14) 所示的状态下，执行`sarahs-repo`中`$ git push origin master`的结果。

![9781430261032_Fig10-15.jpg](images/9781430261032_Fig10-15.jpg)

[图 10-15](#_Fig15) 。在 Sarah-repo 中执行$ git push origin master 命令后，图 10-14 中的存储库的状态

您应该注意到，为了决定应该发送哪些修订，git 只需找到 Sarah 的存储库中两个分支`master`和`origin/master`之间的差异。由于配方 7-2 中讨论的两点，这可以用`$ git log --oneline origin/master..master`命令来完成。该命令打印包含在`master`中但不包含在`origin/master`中的修订列表。

![image](images/sq.jpg) **提示**请记住，远程跟踪分支，比如`origin/master`，可以像普通本地分支一样在 git 提交中使用。例如，命令`$ git branch foo origin/master∼3`创建一个名为`foo`的新的普通本地分支，它指向与`origin/master`的曾祖父相同的修订。

总而言之，推送以下列方式更新分支:

*   在本地存储库远程—跟踪分支被更新为本地跟踪分支中的最新版本
*   在远程存储库中—远程分支被更新为本地跟踪分支中的最新版本

如果推送操作失败会怎么样？如果约翰在他的存储库中执行`$ git push origin master`，如图 10-9 中的[所示，那么推送将被拒绝，并显示以下消息:](#Fig9)

```
! [rejected]        master -> master (fetch first)
```

所有分支保持不变。

拉动如何影响跟踪分支

这一次我们是从约翰的视角观察变化。因此，`johns-repo`是本地存储库，`shared-repo`是远程存储库。

当您从远程存储库提取时，您的本地跟踪分支和远程跟踪分支将会更新。远程分支保持不变。第一种情况(没有合并)在[图 10-16](#Fig16) 和[图 10-17](#Fig17) 中描述。[图 10-16](#Fig16) 显示了拉动操作之前的状态。共享存储库包含不包含在`johns-repo`中的两个修订`b1`和`b2`。拉操作将这些修订带入`johns-repo`，并将分支更新到图 10-17 所示的状态。

![9781430261032_Fig10-16.jpg](images/9781430261032_Fig10-16.jpg)

[图 10-16](#_Fig16) 。在$ git pull origin master 命令之前的 John 的存储库

![9781430261032_Fig10-17.jpg](images/9781430261032_Fig10-17.jpg)

[图 10-17](#_Fig17) 。约翰的仓库在$ git pull origin master 命令后在约翰-repo 中执行如图[图 10-16](#Fig16) 所示

[图 10-18](#Fig18) 和 [10-19](#Fig19) 说明了第二种情况。这是一个快进操作。如果在`$ git pull origin master`期间发生合并，本地跟踪分支`master`和远程跟踪分支`origin/master`以完全相同的方式改变。它们将指向自动生成的合并提交，如图[图 10-18](#Fig18) 和[图 10-19](#Fig19) 所示。

![9781430261032_Fig10-18.jpg](images/9781430261032_Fig10-18.jpg)

[图 10-18](#_Fig18) 。共享回购和约翰回购的主要分支出现分化

![9781430261032_Fig10-19.jpg](images/9781430261032_Fig10-19.jpg)

[图 10-19](#_Fig19) 。在[图 10-18](#Fig18) 中显示的约翰回购中发出的$ git 拉式来源主数据的结果

总而言之，拉操作更新本地跟踪分支和远程跟踪分支，而保持远程分支不变。

![image](images/sq.jpg) **提示**记住:远程分支是远程存储库中的一个分支。远程跟踪分支是本地分支，用作您的工作和远程存储库内容之间的链接。图 5-7 清楚地显示了所有类型的分支。

10-3.为一个提交生成(n-1)个合并提交

问题

如果项目是由 n 个开发人员使用配方 10-2 实现的，您想要检查历史看起来像什么。为此，您需要模拟三个开发人员的工作:John、Sarah 和 Peter。你必须在三个不同的存储库中并行提交:`johns-repo`、`sarahs-repo`、`peters-repo`。然后，您需要同步所有的存储库。正如您将看到的，由`$ git pull`命令生成的历史将包含大量多余的合并提交。在最坏的情况下，一个提交可以生成多达 n-1 个合并提交，其中 n 是所涉及的开发人员的数量。

解决办法

使用以下内容创建新目录:

```
$ cd git-recipes
$ mkdir 10-03
$ cd 10-03
```

然后用以下内容初始化项目:

```
# the command issued in git-recipes/10-03 directory
$ git init --bare shared-repo
```

接下来，John 初始化他的存储库，创建一个初始提交，并将其推送到共享存储库:

```
# commands issued in git-recipes/10-03 directory
$ git clone shared-repo johns-repo
$ cd johns-repo
$ git simple-commit "Initial commit"
$ git push -u origin master
```

然后，另外两个开发人员使用以下内容创建他们的存储库:

```
# commands issued in git-recipes/10-03 directory
$ git clone shared-repo sarahs-repo
$ git clone shared-repo peters-repo
```

现在，所有的开发人员都准备好提交了。在这个配方中，所有的开发人员并行工作。他们每个人都创建了自己的提交:

```
# command issued in johns-repo
$ git simple-commit "The first commit by John"

# command issued in sarahs-repo
$ git simple-commit "The first commit by Sara"

# command issued in peters-repo
$ git simple-commit "The first commit by Peter"
```

现在，他们想分享他们的工作。

John 是第一个将他的更改推送到中央存储库的人:

```
# command issued in johns-repo
$ git push origin master
```

然后莎拉和彼得拉他们的工作:

```
# command issued in sarahs-repo
$ git pull --edit origin master

# command issued in peters-repo
$ git pull --edit origin master
```

他们都输入合并消息。莎拉打字`"Sarah merges..."`，彼得打字`"Peter merges..."`。

现在，莎拉推进她的工作:

```
# command issued in sarahs-repo
$ git push origin master
```

然后彼得试着推:

```
# command issued in peters-repo
$ git push origin master
```

该推送被拒绝，因此 Peter 合并了`shared-repo`中的最新更改:

```
# command issued in peters-repo
$ git pull --edit origin master
```

Peter 将合并提交的消息键入为`"Peter merges again..."`，然后他用:

```
# command issued in peters-repo
$ git push origin master
```

当 John 和 Sara 都接受了 Peter 所做的更改后，菜谱就完成了:

```
# command issued in johns-repo
$ git pull origin master

# command issued in sarahs-repo
$ git pull origin master
```

现在，所有四个存储库都包含了清单 10-3 中的历史。清单显示了在四个存储库中执行的`$ git log --graph --oneline`命令的输出。

[***清单 10-3。***](#_list3) 在菜谱 10-3 中创建的历史

```
*   901f9b1 Peter merges again...
|\
| *   70984f8 Sarah merges...
| |\
| * | ebf6fff The first commit by Sarah
* | |   192af3a Peter merges...
|\ \ \
| | |/
| |/|
| * | 4721211 The first commit by John
| |/
* | 4314f0a The first commit by Peter
|/
* ebb21d1 Initial commit
```

它是如何工作的

这个食谱的目的很简单:我想让你相信食谱 10-2 中提出的解决方案不是你应该遵循的模式。用`$ git pull origin master`命令创建的历史将很难阅读。配方 10-3 向您展示了如果一组 n 个开发人员并行工作，并且每个开发人员创建一个提交，那么第一个开发人员所做的提交将生成 n-1 个合并提交。

在我们的配方中，提交`"The first commit by John"`生成了两个合并:

```
70984f8 Sarah merges...
192af3a Peter merges...
```

很容易认识到，如果团队由 n 个开发人员组成，我们将得到 n-1 个合并提交。

看看清单 10-3 中的。显示的历史仅由三次提交生成:每个开发人员一次。如果您的团队由大量定期提交的开发人员组成，那么命令`$ git pull origin master`将产生一个非常复杂的修订图，其中包含大量多余的合并提交。

![image](images/sq.jpg) **提示**如果你认为清白的历史很重要，你应该把食谱 10-2 当作一个不可遵循的模式。

10-4.保持历史的线性

问题

您希望组织由任意数量的开发人员组成的团队的工作。每个开发人员都将使用自己的存储库。他们将使用一个中央存储库来共享他们的工作。该设置与制作方法 10-2 相同。

这一次您想要定义一个工作流，它将保证所有存储库中主分支的线性结构。不允许合并提交，并且不应出现在任何存储库中。

为了保持历史的线性，所有团队成员都需要在更新的远程跟踪分支之上重新构建他们的工作。

解决办法

使用以下内容创建新目录:

```
$ cd git-recipes
$ mkdir 10-04
$ cd 10-04
```

然后用以下内容初始化一个项目:

```
# the command issued in git-recipes/10-04 directory
$ git init --bare shared-repo
```

现在，John 初始化了他的存储库，创建了一个初始提交，并将其推送到共享回购:

```
# commands issued in git-recipes/10-04 directory
$ git clone shared-repo johns-repo
$ cd johns-repo
$ git simple-commit i1 i2
$ git push -u origin master
```

然后下一个开发人员 Mark 加入了团队:

```
# commands issued in git-recipes/10-04 directory
$ git clone shared-repo marks-repo
```

现在`johns-repo`、`shared-repo`和`marks-repo`包含相同的提交`i1`和`i2`。`$ git status -sb`命令只打印当前分支的名称`master`。所有的存储库都是干净的，并且分支是同步的。所有储存库的状态如图 10-20 所示。

![9781430261032_Fig10-20.jpg](images/9781430261032_Fig10-20.jpg)

[图 10-20](#_Fig20) 。配方 10-4 中所有三个储存库的初始状态

约翰和马克平行工作

约翰和马克同时工作。约翰创建了三个提交`j1`、`j2`、`j3`，马克创建了两个提交`m1`、`m2`:

```
# command issued in johns-repo
$ git simple-commit j1 j2 j3

# command issued in marks-repo
$ git simple-commit m1 m2
```

现在，在约翰的报告中执行的命令:

```
# command issued in johns-repo
$ git status -sb
```

打印以下信息:

```
## master...origin/master [ahead 3]
```

这意味着 John 的`master`分支包含三个修订，这三个修订没有包含在他的`origin/master`跟踪分支中。在 Mark 的存储库中执行的相同命令:

```
# command issued in marks-repo
$ git status -sb
```

产出:

```
## master...origin/master [ahead 2]
```

`marks-repo`中的`master`分支包含两个修订，这两个修订不包括在马克的`origin/master`跟踪分支中。

所有三个储存库的状态如图 10-21 所示。

![9781430261032_Fig10-21.jpg](images/9781430261032_Fig10-21.jpg)

[图 10-21](#_Fig21) 。约翰的主分支领先三个，马克的主分支领先两个的状态

约翰成功地将他的作品上传到共享存储库

现在开发人员想要分享他们的工作。John 是第一个将他的更改推送到中央存储库的人:

```
# command issued in johns-repo
$ git push origin master
```

约翰的命令成功了。当 John 再次运行`$ git status -sb`时，输出不再包含`[ahead: 3]`。他的`master`分支现在与他的`origin/master`分支完全同步。

Mark 解决了分叉的问题

共享存储库已经更改，因为 John 已经上传了他的修订。但是马克不知道这件事。他的命令`$ git status -sb`返回与之前完全相同的信息:`[ahead 2]`。请记住，此信息仅涉及 Mark 的本地分支机构。他们还没有更新。Mark 的存储库和共享存储库现在看起来像[图 10-22](#Fig22) 。马克的知识库中没有约翰的修订版`j1`、`j2`和`j3`。

![9781430261032_Fig10-22.jpg](images/9781430261032_Fig10-22.jpg)

[图 10-22](#_Fig22) 。John 已成功将其 j1、j2 和 j3 版本推送到共享回购，因此 Mark 无法推送到 m1 和 m2 版本

马克想用以下方式推进他的工作:

```
# command issued in marks-repo
$ git push -u origin master
```

但是这个操作被拒绝，因为推送不是快进。

马克需要更新他的`master`分支。他首先从共享存储库中获取最新的修订:

```
# command issued in marks-repo
$ git fetch origin
```

为了检查他的存储库的状态，Mark 运行了`$ git status -sb`命令。它打印:

```
## master...origin/master [ahead 2, behind 3]
```

现在马克知道他的`master`和`origin/master`主分支已经分叉。`[ahead 2]`通知他，Marks 的`master`分支包含两个不在他的`origin/master`分支中的修订。打印出`[behind 3]`是因为 Mark 的`master`分支遗漏了他的`origin/master`分支中包含的三个修订。

使用`$ git log --graph --all --oneline --decorate`马克可以想象他的`master`分支和他的`origin/master`分支分叉。图 10-23 中的[显示了 Mark 的存储库和共享存储库的状态。](#Fig23)

![9781430261032_Fig10-23.jpg](images/9781430261032_Fig10-23.jpg)

[图 10-23](#_Fig23) 。$ git fetch origin 后 Mark 的回购状态

为了保持历史的线性，Mark 将他的`master`分支放在从共享存储库中获取的`origin/master`分支之上:

```
# command issued in marks-repo
$ git rebase origin/master master
```

现在马克的`master`分支的历史是线性的，他的基础修订`m1'`、`m2'`和`m3'`在顶部。马克想确保万无一失，所以他运行了`$ git log --graph --oneline --decorate`或`$ gitk --all &`命令。储存库的状态如图 10-24 中[所示。](#Fig24)

![9781430261032_Fig10-24.jpg](images/9781430261032_Fig10-24.jpg)

[图 10-24](#_Fig24) 。$ git rebase origin/master master 后的马克回购

在`marks-repo`中执行的命令`$ git status -sb`如图[图 10-24](#Fig24) 打印:

```
## master...origin/master [ahead 2]
```

后面的消息消失了，因为 Mark 的`master`分支现在包含了来自他的`origin/master`分支的所有修订。

当处于`[ahead 3]`状态时，Mark 可以将其工作推送到共享存储库:

```
# command issued in marks-repo
$ git push -u origin master
```

这次接受推送。它转换共享存储库，如图[图 10-25](#Fig25) 所示。

![9781430261032_Fig10-25.jpg](images/9781430261032_Fig10-25.jpg)

[图 10-25](#_Fig25) 。Mark 成功执行$ git push -u origin master 后的 Mark-repo 和 shared-repo

马克的工作完成了。`$ git status -sb`的输出中没有超前或滞后信息。这意味着马克回购中的`master`和`origin/master`分支是同步的。

约翰下载马克的作品

现在约翰的回购和共享回购看起来像[图 10-26](#Fig26) 。

![9781430261032_Fig10-26.jpg](images/9781430261032_Fig10-26.jpg)

[图 10-26](#_Fig26) 。在 John 的$ git fetch 命令之前的 Shared-repo 和 johns-repo

约翰可以用下面的命令获取马克的工作:

```
# command issued in johns-repo
$ git fetch
```

该命令将把图 10-26 中[所示的存储库转换成图 10-27](#Fig26) 中[所示的形式。](#Fig27)

![9781430261032_Fig10-27.jpg](images/9781430261032_Fig10-27.jpg)

[图 10-27](#_Fig27) 。John 的$ git fetch 命令后的 repo

当约翰的存储库处于图 10-27 中[所示的状态时，那么`$ git status -sb`命令打印:](#Fig27)

```
## master...origin/master [behind 2]
```

因此，John 的`master`分支遗漏了他的`origin/master`分支中包含的两个修订。John 可以使用以下命令快进他的分支:

```
# command issued in johns-repo
$ git rebase
```

图 10-27 中[所示的存储库随着 John 的`$ git rebase`命令转换成图 10-28](#Fig27) 中[所示的状态。所有存储库的历史都是线性的。](#Fig28)

![9781430261032_Fig10-28.jpg](images/9781430261032_Fig10-28.jpg)

[图 10-28](#_Fig28) 。约翰的回购后，他的$ git rebase 命令

它是如何工作的

Git 获取命令执行两个操作:

*   它将对象从远程数据库复制到本地数据库。
*   它更新远程跟踪分支。

但是，它不会更新本地跟踪分支。有两个有趣的例子:

*   当命令`$ git fetch`运行后，可以快进的方式更新本地分支。
*   当命令`$ git fetch`运行后，本地分支分叉。

在图 10-26 中[所示的库`johns-repo`中执行时，`$ git fetch`命令会产生图 10-27](#Fig26) 中[所示的效果。这是一个快进的案例。在这种情况下,`$ git status -sb`命令打印:](#Fig27)

```
## master...origin/master [behind 2]
```

这意味着本地跟踪分支`master`遗漏了包含在远程跟踪分支`origin/master`中的两个修订。

分支分叉的情况如图[图 10-23](#Fig23) 所示。图 10-22[中`marks-repo`执行的命令`$ git fetch`产生图 10-23](#Fig22) 中[所示的结果。这一次`$ git status -sb`的输出将是:](#Fig23)

```
## master...origin/master [ahead 2, behind 3]
```

因此，本地跟踪分支比远程跟踪分支提前两次修订，落后三次修订。

将本地跟踪分支重置为远程跟踪分支

远程跟踪分支，比如`origin/master`，就是本地分支。它们可以像普通的本地分支一样使用。因此，为了保持历史线性，我们可以使用`$ git rebase`命令，如配方 7-1 所述。图 10-23[中`marks-repo`发出的命令`$ git rebase origin/master master`会产生图 10-24](#Fig23) 中[所示的效果。](#Fig24)

如果设置主分支的跟踪，那么命令`$ git rebase origin/master master`可以简化为:

```
$ git rebase
```

它在其远程跟踪分支之上执行当前本地跟踪分支的重置。

你也可以使用`$ git pull`命令来达到同样的效果。默认情况下，命令`$ git pull`被执行为`$ git fetch`，后跟`$ git merge`。虽然改变这种行为，你可以使用`-r`标志或配置设置。命令`$ git pull -r`相当于`$ git fetch`后跟`$ git rebase`。

记住,`$ git fetch`命令更新您的本地数据库和远程跟踪分支。它不会影响您的本地跟踪分支机构或您的普通本地分支机构。因此，您可以随时安全运行`$ git fetch`。它不会给你带来任何麻烦。

消息[前方 x]和[后方 y]

正如您已经看到的，可以使用`$ git status -sb`命令检查本地跟踪分支和远程跟踪分支之间的关系。在本地跟踪分支和远程跟踪分支指向不同修订的情况下，该命令的输出包含部分`[ahead N, behind M]`，如:

```
## master...origin/master [ahead 2]
## master...origin/master [behind 2]
## master...origin/master [ahead 2, behind 1]
```

`[ahead 2]`消息表明本地跟踪分支比远程跟踪分支领先两个版本。这是您在本地跟踪分支中提交后将获得的状态。

`[behind 2]`消息表明您的本地跟踪分支在远程跟踪分支之后。您的本地跟踪分支缺少远程跟踪分支中可用的两个修订。当您团队中的某个成员将他或她的提交推送到共享存储库，并且您使用`$ git fetch`命令将它们下载到您的存储库时，您就处于这种状态。

最后的消息`[ahead 2, behind 1]`意味着本地跟踪分支和远程跟踪分支已经分离。本地跟踪分支包含两个不在远程跟踪分支中的修订，同时它丢失了远程跟踪分支中包含的一个修订。在执行了`$ git commit`和`$ git fetch`命令之后，您获得了这个状态，假设有人推送到共享存储库。

访问远程分支

请记住，`$ git status -sb`和`$ git branch -a -vv`命令只适用于您的本地分支。它们是:普通本地分支、本地跟踪分支和远程跟踪分支。命令`$ git status`和`$ git branch`不访问远程存储库中的远程分支。远程分支仅在`$ git fetch`期间转移到您的存储库。因此，如果您想检查远端，您需要运行`$ git fetch`，然后运行`$ git status -sb`或`$ git branch -a -vv`。但是无论您的速度有多快，`$ git status -sb`或`$ git branch -a -vv`的结果可能已经过时，因为有人可能已经在您获取之后和您执行`$ git status -sb`或`$ git branch -a -vv`之前将其推送到远程存储库。

为什么跟踪分支很重要

你应该注意到了`$ git status -sb` 总是比较本地跟踪分支和远程跟踪分支。这种比较是为您当前的分支执行的。为了获得`$ git status -sb`的`[ahead N, behind M]`输出，您需要为您当前的分支定义跟踪。如果您的配置文件`.git/config`中没有`[branch"..."]`条目，例如:

```
[branch "master"]
    remote = origin
    merge = refs/heads/master
```

然后 git 就不知道比较哪个分支了。`$ git status -sb`的输出将不包含`[ahead N, behind M]`信息。

当您克隆一个存储库时，git 会自动为您的`master`分支配置跟踪。Git 还会在您向 checkout 命令传递远程分支的名称时设置跟踪—如配方 5-2 中的`$ git checkout doc` 。否则，您必须手动设置跟踪。以下是一些不同的解决方案:

*   `$ git branch --set-upstream-to=origin/master`命令(如配方 10-1 中的提示所示)
*   `$ git push -u origin master`命令(如配方 10-2 中的提示所示)
*   `$ git config branch`命令(如配方 10-1 中的提示所示)
*   手动编辑`.git/config`文件

一旦设置，跟踪信息可用于简化许多命令。如果您当前在被设置为跟踪`origin/master`分支的`master`分支上，那么三个命令`$ git rebase` 、`$ git rebase origin/master` 和`$ git rebase origin/master master` 是等效的。

基本上，定义跟踪分支有两个原因:

*   `$ git status -sb`命令可以与`$ git fetch`一起使用，以确定您的分支是否与远程分支同步。
*   许多命令可以简化为缺少参数——如在`$ git rebase`中——以默认跟踪分支。

10-5.没有中央存储库的协同工作

问题

您想要模拟两个开发人员 John 和 Sarah 在没有中央存储库的情况下的合作。在这种情况下，协同工作将由两个存储库组成:

*   第一个开发者的非裸存储库
*   `10-05/sarahs-repo`—第二个开发者的非裸库

两个开发人员都将在他们的`master`分支内提交。约翰将使用`sarah`分支获取莎拉的工作，莎拉将使用`john`分支获取约翰的工作。

提示这个食谱强调了 git 的分布式本质，每个人都可以相互合作。

解决办法

使用以下内容创建新目录:

```
$ cd git-recipes
$ mkdir 10-05
$ cd 10-05
```

这项工作是由一个开发人员初始化的。让它成为约翰。他初始化了他的知识库:

```
# john's commands in git-recipes/10-05 directory
$ git init johns-repo
```

然后他设置他的个人数据:

```
# john's commands
$ cd johns-repo
$ git config --local user.name john
$ git config --local user.email john@example.net
```

并提交:

```
# john's command
$ git simple-commit j1 j2 j3
```

现在莎拉进入了这个项目。她克隆了`johns-repo`并配置了她的个人信息:

```
# sarah's commands
# executed in git-recipes/10-05
$ git clone johns-repo sarahs-repo
$ cd sarahs-repo
$ git config --local user.name sarah
$ git config --local user.email sarah@example.net
```

接下来，Sarah 对项目进行了两次修订`s1`和`s2`:

```
# sarah's command
$ git simple-commit s1 s2
```

当提交准备好被获取时，Sarah 给 John 发电子邮件告知她的`s1 s2`修订。为了获得它们，John 需要建立远程存储库和本地跟踪分支。约翰跑了:

```
# john's command
$ git remote add origin ../sarahs-repo
```

然后，他用`$ git fetch`从 Sarah 的存储库中取出远程分支，作为到他的存储库中的远程跟踪分支。该命令创建了`origin/master`远程跟踪分支，该分支与 John 存储库中的本地`master`分支没有任何关系。可以用`$ git branch -a -vv`查一下。关于他的`master`分行的行不包含`[origin/master]`部分。看起来像是:

```
* master                abc123f s2
```

它证明它仍然是一个普通分支，因为本地跟踪分支包含`[origin/master]`，如:

```
* master                abc123f [origin/master] s2
```

接下来，John 创建了一个名为`sarah`的普通本地分支:

```
# john's command run in 10-05/johns-repo
$ git branch sarah
```

并且他将他的`sarah`分支配置为`origin/master`分支的本地跟踪分支:

```
# john's command
$ git branch --set-upstream-to=origin/master sarah
```

为了检查莎拉在`s1`和`s2`版本中编写的代码，约翰带着:

```
# john's command
$ git checkout sarah
```

该分支还不包含`s1`和`s2`修订，证明如下:

```
# john's command
$ git status -sb
```

输出通知您，他的当前分支(`sarah`)比它的远程跟踪分支(`origin/master`)晚两次提交。John 更新了他的`sarah`分支:

```
# john's command
$ git rebase
```

现在约翰的存储库中的`sarah`分支包含了`s1`和`s2`修订。约翰可以分析莎拉的贡献。当他认为这些修改没问题时，他可以将它们合并到自己的工作中:

```
# john's commands
$ git checkout master
$ git rebase sarah
```

现在是约翰进行更多修改的时候了。他跑`$ git simple-commit j4 j5 j6`。然后他给莎拉发电子邮件询问他的工作。

轮到莎拉下载约翰在修订版`j4`、`j5`和`j6`中贡献的代码。她用`$ git clone`命令开始工作，因此她的存储库中已经包含了`.git/config`条目，该条目将她的`master`分支设置为`origin/master`远程跟踪分支的本地跟踪分支。可以用`$ git branch -a -vv`命令检查。它输出:

```
* master                40695ac [origin/master] s2
  remotes/origin/master 604549f j3
```

片段`[origin/master]`表示`master`分支是`origin/master`远程跟踪分支的本地跟踪分支。要删除此关系，Sarah 运行:

```
# sarah's command
$ git config --unset branch.master.remote
$ git config --unset branch.master.merge
```

上述命令后，`$ git branch -a -vv`输出:

```
* master                40695ac s2
  remotes/origin/master 604549f j3
```

尽管她的存储库仍然包含名为`origin/master`的远程跟踪分支，但是她的本地`master`分支没有与之连接。这两个`$ git config --unset`命令将她的本地跟踪分支`master`变成了一个普通的本地分支。很好。

现在，Sarah 想要创建名为`john`的本地跟踪分支，以便与 John 的`master`分支相连接。她跑了:

```
# sarah's command
$ git branch john
$ git branch --set-upstream-to=origin/master john
```

然后她用`$ git fetch`从约翰的仓库里取东西。该命令从约翰的回购协议中的`master`分支以及一个新的远程跟踪分支`remotes/origin/sarah`获取所有丢失的修订。莎拉不需要约翰的`origin/sarah`分支，但是没有办法避开。

接下来，Sarah 切换到`john`分支并检查其状态:

```
# sarah's command
$ git checkout john
$ git status -sb
```

输出表明当前分支(`john`)比远程跟踪分支(`origin/master`)晚三次提交。她更新了她的`john`分支:

```
$ git rebase
```

她检查约翰的修改`j4`、`j5`、`j6`。然后，她将约翰的工作并入她的`master`分支:

```
$ git rebase john master
```

约翰如何更新他的项目？

为了下载并合并 Sarah 的所有代码，John 运行以下命令:

```
$ git fetch
$ git checkout sarah
$ git rebase
$ git rebase sarah master
```

开发人员如何对项目做出贡献？

每个开发人员通过在他或她的`master`分支中承诺:

```
$ git checkout master
$ git simple-commit x y z
```

莎拉如何下载约翰的稿件？

她遵循程序*约翰如何更新他的项目？*使用`john`分支名称代替`sarah`:

```
$ git fetch
$ git checkout john
$ git rebase
$ git rebase john master
```

它是如何工作的

这个食谱强调了 git 的分布式本质。如您所见，每个存储库都可以用作修订源。您可以从您有权访问的每个存储库中获取数据。Git 不限制对一些特殊的中央存储库的获取，就像 Recipe 10-2 中的`shared-repo`一样，存储在服务器上。默认情况下，推送操作仅限于裸存储库，但是我们也可以避开这一限制。这将在配方 10-10 中完成。

如果您仔细遵循这个方法，您会注意到`$ git fetch`操作为远程存储库中的所有分支创建了远程跟踪分支。当您完成菜谱时，John 的存储库包含以下分支(由`$ git branch -a -vv`返回):

```
* master                542d21a z
  sarah                 bacddd0 [origin/master] j6
  remotes/origin/john   bacddd0 j6
  remotes/origin/master bacddd0 j6
```

有两个远程分支`origin/master`和`origin/john`。第二个是 Sarah 在`sarahs-repo`中创建的远程`john`分支的远程跟踪分支。约翰不需要也不使用它，但它还是被创造出来了。最后，记住`$ git fetch`获取所有的远程分支，并将它们存储为远程跟踪分支。

这个过程还向您展示了您可以使用以下命令将名为`some-branch`的本地跟踪分支转换成普通的本地分支:

```
$ git config --unset branch.some-branch.remote
$ git config --unset branch.some-branch.merge
```

10-6.使用远程分支

问题

您和您的同事想要使用一个包含许多分支 的共享存储库，而不仅仅是一个主分支。这将让你有机会将团队重组为从事不同功能的小组。要处理项目中一个名为 foo 的特定特性，您需要创建一个名为 foo 的远程分支，存储在共享存储库中。使用 foo 特性的开发人员应该使用 foo 远程分支来共享他们的工作。

这个菜谱为您提供了操作远程分支所需的所有命令。您将学习如何:

*   创建一个与本地分支同名的远程分支
*   使用不同于本地分支的名称创建远程分支
*   删除远程分支
*   更新您的存储库以反映远程分支中的更改

解决办法

创建一个新目录并初始化和一个共享存储库:

```
$ cd git-recipes
$ mkdir 10-06
$ cd 10-06
$ git init --bare shared-repo
```

接下来为 John 创建一个存储库，创建一个初始版本 ，并将其发送给`shared-repo`:

```
$ git clone shared-repo johns-repo
$ cd johns-repo
$ git simple-commit "Initial commit"
$ git push -u origin master
```

然后为 Sarah 创建一个存储库:

```
$ git clone shared-repo sarahs-repo
```

让我们假设约翰是领导。他负责为所有团队成员设定任务。他决定团队的一些成员(包括 Sarah)将从事文档工作。这项工作将在一个名为`doc`的分支中完成。为此，John 在他的存储库中创建了一个新的普通本地分支，名为`doc` `:`

```
# john's command
$ git branch doc
```

然后，John 将该分支提供给其他开发人员。他将他的 doc 分支推入`shared-repo`中:

```
# john's command
$ git push -u origin doc
```

上述命令在`johns-repo`中为`doc`分支设置跟踪。在上面的命令之后，`shared-repo`包含了`doc`分支。您可以验证它正在运行:

```
# shared-repo's command
$ git branch
```

接下来，John 想要开始一个特定的单元测试工作。他创建了一个名为`test`的普通本地分支:

```
# john's command
$ git branch test
```

他意识到这个名字可能已经被许多团队成员用于他们自己的私人工作，这些工作与单元测试没有任何关系。因此，约翰决定将远程分支命名为`special-unit-tests` 。他用下面的命令将他的本地`test`分支推到`special-unit-tests`名下:

```
# john's command
$ git push -u origin test:special-unit-test
```

上面的命令在别名为`origin`的远程存储库中创建了一个名为`special-unit-test`的远程分支。用以下方式检查:

```
# shared-repo's command
$ git branch
```

让我们假设 Sarah 被分配从事文档和测试工作。她从遥控器里取出:

```
# sarah's command
$ git fetch
```

该命令在`sarahs-repo`中创建远程跟踪分支`origin/doc`和`origin/special-unit-tests`。

一段时间过去了，`doc`和`special-unit-tests`异地分公司的工作顺利通过。成员们使用配方 10-4 来同步他们的工作。

约翰从`doc`分公司下载了最新版本。他决定小组工作结束。远程`doc`分支应该被删除。约翰删除远程`doc`分支:

```
# john's command
$ git push origin :doc
```

上述命令执行了以下操作:

*   删除了`shared-repo.`中的`doc`分支
*   它删除了远程跟踪分支`johns-repo.`中的`origin/doc`
*   然而，它没有将`johns-repo`中的本地跟踪分支`doc`转换成普通的本地分支。`johns-repo`中的`doc`分公司还在跟踪一个不存在的`origin/doc`远程跟踪分公司。您可以使用`$ git branch -avv`命令验证这一点。

![image](images/sq.jpg) **提示**本地跟踪分公司和普通本地分公司有什么区别？当然，你可以在这两种情况下都做出承诺。但是本地跟踪分支连接到远程跟踪分支；因此，您可以使用`$ git status -sb`来检查本地跟踪分支是在相应的远程跟踪分支之前还是之后。

因此，`shared-repo`不再包含`doc`分支。在`shared-repo`中执行的`$ git branch` 命令打印两个分支:`master`和`special-unit-tests`。然而，在 John 的存储库中，分支`doc`仍然存在——它是一个普通的本地分支。

Sarah 更新了她的远程分支机构:

```
# sarah's command
$ git fetch
```

然而，上面的命令不会删除`shared-repo`中不存在的远程分支`doc`的远程跟踪分支`origin/doc`。如果 Sarah 想要更新她的存储库，以反映已删除的远程分支，她需要以下命令:

```
# sarah's command
$ git remote prune origin
```

上面的命令删除了 Sarah 存储库中的远程跟踪分支`origin/doc`。该操作可在提取过程中通过附加的`-p`标志自动执行:

```
# sarah's command
$ git fetch -p
```

现在`doc`分支的工作已经完成。在共享存储库中或者在除 John 之外的任何其他成员的存储库中没有远程分支`doc`。约翰是领导，他负责将`doc`分公司整合到`master`分公司。他可以使用[第 6 章](06.html)和[第 7 章](07.html)中讨论的任何方法。例如，他可以将`doc`分支合并到`master`分支中，从而形成一个灯泡。配方 7-6 中给出了确切的程序。一旦 John 将`doc`分支集成到`master`分支中，他就会将包含`doc`分支的主分支推送到共享存储库中。这完全按照配方 10-4 来做，也许(如果约翰需要给灯泡换底)按照配方 7-9 来做。

约翰可以使用 gitolite 限制对远程分支机构的访问，如配方 11-10 中所述。

它是如何工作的

命令:

```
$ git push [remote-name] [branch-name]
```

在别名为`remote-name`的存储库中创建名为`branch-name` 的远程分支。为了成功，分支`branch-name`必须存在于您正在工作的存储库中。然而，它不一定是你现在的分行。如果您想推动当前分支，您可以使用:

```
$ git push [remote-name] HEAD
```

用于一个没有`-u` 的普通本地分支，如:

```
$ git push origin doc
```

该命令执行三个操作:

*   它在本地存储库中创建一个远程跟踪分支`origin/doc`。
*   它在远程存储库中创建一个远程分支`doc`。
*   它将所需的修订从本地数据库发送到远程数据库。

如果您使用`-u`标志，那么普通本地分支`doc`将被转换为远程跟踪分支`origin/doc`的本地跟踪分支。

这就是如何创建一个与本地分支同名的远程分支。如果要创建不同名称的远程分支，则本地分支使用以下语法:

```
$ git push [remote-name] [local-branch-name]:[remote-branch-name]
```

命令:

```
$ git push origin foo:bar

```

发送名为`foo`的本地分支，并将其存储在远端的`bar`名下。上面的命令:

*   在远程存储库中创建远程分支`bar`
*   在本地存储库中创建远程跟踪分支`origin/foo`
*   将本地分支`foo`设置为远程跟踪分支`origin/foo`的本地跟踪分支

如果要删除远程分支，请使用:

```
$ git push [remote-name] :[remote-branch-to-remove]
```

就像:

```
$ git push origin :foo
```

上面的命令:

*   删除`origin`中的远程分支`foo`
*   删除本地存储库中的远程跟踪分支`origin/foo`
*   它不会删除您的本地跟踪分支`foo.`
*   它不会将本地跟踪分支`foo`转换成普通的本地分支；您当地的`foo`分支仍然跟踪一个不存在的`origin/foo`分支。

您可以通过以下方式删除本地分支:

```
$ git branch -d foo
```

或者您可以将其更改为普通的本地分支机构，方法是:

```
$ git config --unset branch.foo.remote
$ git config --unset branch.foo.merge
```

每次运行`$ git fetch` 时，所有的远程分支都被复制到您的存储库中作为远程跟踪分支。但是如果您删除了一个远程分支，那么默认情况下，这个变更不会在其他开发人员中传播。每个开发人员都可以通过以下方式删除过时的远程跟踪分支:

```
$ git remote prune origin
```

以上命令删除不存在的远程分支的所有远程跟踪分支。在提取过程中，可以使用以下方法完成同样的操作:

```
$ git fetch -p
```

上述命令执行两项操作:

```
$ git fetch
$ git remote prune
```

10-7.使用远程分支机构捐款

问题

你是一个大型项目的开发人员之一。为了同步工作，整个团队使用带有远程分支的共享存储库。在本食谱中，我们将使用以下设置:

*   `10-07/leaders-repo`——一个项目领导者的非裸露知识库
*   `10-07/johns-repo`—您的非裸存储库
*   `10-07/shared-repo`—用于同步的空存储库

你负责新网页界面的工作。您计划使用名为`new-web-interface`的分支与团队共享您的工作。特别是，您希望:

*   创建一个名为`new-web-interface`的本地分支
*   在您的本地分支机构提交`new-web-interface`
*   将您的本地`new-web-interface`推送到一个共享存储库中，由项目负责人进行审查

解决办法

创建新目录并初始化领导者的存储库:

```
$ cd git-recipes
$ mkdir 10-07
$ cd 10-07
$ git init leaders-repo
$ cd leaders-repo
$ git simple-commit "Initial commit"
```

接下来创建一个共享存储库:

```
# command issued in git-recipes/10-07 directory
$ git clone --bare leaders-repo shared-repo
```

领导者需要在他或她的存储库中添加源别名:

```
# command issued by leader in 10-07/leaders-repo directory
$ git remote add origin ../shared-repo
```

此时，您加入了团队:

```
# command issued in git-recipes/10-07 directory
$ git clone shared-repo johns-repo
```

因为我们将复制在这个菜谱中创建的三个存储库，John 需要重新定义他的原点以使用相对路径:

```
# command issued in 10-07/johns-repo directory
$ git remote rm origin
$ git remote add origin ../shared-repo
```

为了对项目有所贡献，请遵循以下程序(所有命令都应在`10-07/johns-repo`中发出):

1.  为您的贡献创建分支:`$ git checkout -b new-web-interface`
2.  在您的`new-web-interface`分支中提交:`$ git simple-commit a b c`
3.  将分支发送到共享存储库:`$ git push -u origin new-web-interface`

现在，您的贡献被存储在远程存储库`shared-repo`的远程分支`new-web-interface`中。

它是如何工作的

这个方法为组织项目成员的合作提供了一个更加方便的解决方案。通过为任务使用专用的远程分支，您可以在团队内部设置组时获得更大的灵活性。您还可以在将代码合并到主分支之前检查它。

10-8.接受捐款

问题

你是一个项目的领导者。您团队中的一名成员使用`new-web-interface`分支将一些代码推送到共享存储库中。你要检查贡献的代码。在这个食谱中，我们假设代码是正确的，你(记住，你是领导者)接受它。

在这个食谱中，我们使用了食谱 10-7 中的场景。你在`leaders-repo`担任领导工作。

解决办法

复制配方 10-7 中的所有储存库:

```
$ cd git-recipes
$ cp -R 10-07 10-08
$ cd 10-08
```

现在你是一个领导者，你检查`new-web-interface`分支中的贡献(所有的命令都应该在`10-08/leaders-repo`中发出):

1.  您获取投稿:`$ git fetch`
2.  您签出远程分支`$ git checkout new-web-interface`
3.  你用任意的命令和工具检查文件，例如，`$ ls`、`$ cat a.txt`、`vi b.txt`
4.  您可以使用任意命令检查修订，例如，`$ git log --oneline`、`$ git log --oneline --name-only HEAD∼3..HEAD`
5.  你决定代码是正确的，应该合并到`master`分支。
6.  你检查`master`分支:`$ git checkout master`
7.  你把工作合并到`master`和`$ git merge new-web-interface`中
8.  您将作品发布给所有其他团队成员:`$ git push origin master`

它是如何工作的

将`new-web-interface`分支整合到主分支的主开发线包括两个步骤。首先，领导者必须获取在`new-web-interface`中完成的工作。这是通过`$ git fetch`和`$ git checkout new-web-interface`命令完成的。在这两个命令之后，领导者有了一个名为`new-web-interface`的地方分支。

因为`new-web-interface`是一个本地分支，所以可以用[第 6 章](06.html)和[第 7 章](07.html)中讨论的任意方法进行整合。这里我们使用了简单的`$ git merge`命令。也可以用`$ git merge --no-ff`或`$ git rebase`来完成。

一旦`new-web-interface`分支被集成到`master`中，它就可以被公开。为此，领导者将`master`分支推入`shared-repo`。

10-9.向远程分支追加提交

问题

你是一个已经将自己的工作推到共享存储库中的`new-web-interface`分支的开发人员。领导让你做一些改进。您将在`new-web-interface`分支中进行一些新的提交。

在这个食谱中，我们使用了食谱 10-7 中的场景。你作为一名开发人员在`johns-repo`工作。

解决办法

复制配方 10-7 中的所有储存库:

```
$ cd git-recipes
$ cp -R 10-07 10-09
$ cd 10-09
```

领导怎么下载你作品的第一版？

为了下载你的工作的第一个版本，领导者更新他的存储库(命令应该在`10-09/leaders-repo`中运行):

*   他取你的修改:`$ git fetch.`
*   他去了`new-web-interface`分支:`$ git checkout new-web-interface`。

开发人员如何向远程分支追加提交？

要添加新的提交，请遵循以下步骤(命令应该在`10-09/johns-repo`中运行):

1.  转到`new-web-interface`分支:`$ git checkout new-web-interface`
2.  创建新的提交:`$ git simple-commit n1 n2 n3 n4 n5`
3.  发布您的作品:`$ git push origin new-web-interface`

领导如何从远程分支机构下载最新版本？

领导者更新他的存储库(命令应该在`10-09/leaders-repo`中运行):

1.  他取你的修改:`$ git fetch`
2.  他去了`new-web-interface`分支:`$ git checkout new-web-interface`
3.  他更新了`new-web-interface`分支:`$ git rebase origin/new-web-interface`

现在他可以检查你的新修改并接受它们(如食谱 10-8)或要求新的改进(如食谱 10-9)。因为领导者用`$ git checkout new-web-interface`命令创建了他的本地`new-web-interface`分支，所以为该分支设置了跟踪。因此他可以在`new-web-interface`上使用`$ git rebase`来更新这个分支。

它是如何工作的

您用于投稿的分支可以由您和您团队的其他成员在更长的时间内使用。您可以迭代地提交并请求代码评审。这样可以重复很多次。菜谱解释了领导者如何用`new-web-interface`分支中的最新变化来更新他的存储库。

当然这些相同的程序:

*   向远程分支追加新提交
*   从远程分支下载最新提交

can be performed by every member. Thus you can use the `new-web-interface` branch as a way to collaborate with others while working on a given feature.

10-10.用$ git push -f 重写历史

问题

你是团队的一员。你把工作推到了一个叫`new-web-interface`的远程分支。你的作品被拒绝了很多次。你被一次又一次地要求改正。因此，远程分支`new-web-interface`包含大量提交。你负责`new-web-interface`远程分部。领导者要求您将该分支中的所有提交压缩成一个提交，然后他才能最终合并它。

在这个食谱中，我们使用了食谱 10-7 中的场景。你作为一名开发人员在`johns-repo`工作。

解决办法

复制配方 10-7 中的所有储存库:

```
$ cd git-recipes
$ cp -R 10-07 10-10
$ cd 10-10
```

现在你是一名在`10-10/johns-repo`的`new-web-interface`工作的开发者:

您的本地`new-web-interface`分支包含三个版本`a`、`b`和`c`。您希望压缩它们并更新远程分支。

以下是您必须遵循的程序(所有命令都将在`10-10/johns-repo`中执行):

1.  转到`new-web-interface`分支:`$ git checkout new-web-interface`
2.  您的`new-web-interface`分支包含三个版本`a`、`b`和`c`。你可以和`$ git log --oneline`核实一下。
3.  修订`a`、`b`、`c`还没有合并到`master`分支。你可以用`$ git log --oneline master..new-web-interface`查一下
4.  Squash your three commits with: `$ git rebase -i HEAD∼3`. Use the following interactive rebasing subcommands:

    ```
    reword XXXXXXX a
    fixup  XXXXXXX b
    fixup  XXXXXXX c
    ```

    将新版本的注释设置为`abc`。交互式重置基础的细节在配方 8-3 中描述。

5.  您的`new-web-interface`分支包含一个新的修订`abc`。你可以和`$ git log --oneline`核实一下。
6.  版本`abc`还没有合并到`master`分支中。你可以用`$ git log --oneline master..new-web-interface`查一下
7.  使用`$ git push -f origin new-web-interface`重新发布您的作品

它是如何工作的

命令`$ git push -f origin new-web-interface`强制 git 更新远程分支`new-web-interface`,即使这会导致历史被重写。默认情况下，`$ git push`只对快速更新成功。如果你知道你在做什么，你可以使用`-f`标志来强制转移。

Git 允许您配置一个拒绝所有使用`$ git push`的非快进更新的存储库，即使使用了`-f`标志。您可以通过将`receive.denyNonFastForwards`设置为`true`来实现这一点。如果你跑步:

```
$ git config receive.denyNonFastForwards true
```

在`shared-repo`中，你将禁止所有改变历史的推送。

![image](images/sq.jpg) **提示**其他关于推送的选项可以在`$ git config --help`手册中找到。很多都是以`receive`开头的前缀。

10-11.完成远程分支的工作

问题

你是团队的一员。你把你的工作推到了名为`new-web-interface`的远程分支。该分支被整合到`master`分支中，不再使用。领导要求您移除 远程分支`new-web-interface`。您还想删除您的本地分支。

在这个食谱中，我们使用了食谱 10-8 中的场景。你作为一名开发人员在`johns-repo`工作。

解决办法

复制配方 10-8 中的所有储存库:

```
$ cd git-recipes
$ cp -R 10-08 10-11
$ cd 10-11
```

现在你是约翰。所有命令都应该在`10-11/johns-repo`中运行:

1.  您用`$ git fetch`更新您的项目。
2.  转到`master`分支:`$ git checkout master`
3.  用`$ git rebase origin/master`更新您的`master`分支
4.  检查可以安全移除的分支:`$ git branch --merged`。输出应包括—除其他外— `new-web-interface`分支。这意味着可以安全地删除`new-web-interface`分支。命令`$ git branch --merged`是一个安全检查:如果分支`new-web-interface`没有被打印，那么删除分支是不安全的。
5.  移除`shared-repo`中的远程分支`new-web-interface`以及带有`$ git push origin :new-web-interface`的本地跟踪分支`origin/new-web-interface`
6.  最后用`$ git branch -d new-web-interface`删除你的`new-web-interface`分支

它是如何工作的

食谱中发生的一件奇怪的事情在食谱 10-6 中已经提到过了。在步骤 5 中使用以下命令删除远程分支后:

```
$ git push origin :new-web-interface
```

`$ git branch -a -vv`命令打印:

```
* master                59de3b0 [origin/master] z
  new-web-interface            59de3b0 [origin/new-web-interface] z
  remotes/origin/HEAD   -> origin/master
  remotes/origin/master 59de3b0 z
```

这意味着`new-web-interface`分支仍然是本地跟踪分支。它跟踪不再存在的`origin/new-web-interface`分支。我们通过在步骤 6 中完全删除`new-web-interface`分支来解决这个矛盾。

10-12.推送到非空存储库

问题

您在一个从非裸存储库克隆而来的存储库中工作。即使原始存储库不是一个空存储库，您也希望将其推送到原始存储库。在这个食谱中，我们将使用两个储存库:

*   `johns-repo`—您提交的非裸存储库
*   `public-repo`—一个你推送到的非裸库

解决办法

使用以下内容创建新目录:

```
$ cd git-recipes
$ mkdir 10-12
$ cd 10-12
```

用以下内容初始化 johns-repository:

```
# commands issued in git-recipes/10-12 directory
$ git init johns-repo
$ cd johns-repo
$ git simple-commit "Initial commit"
```

接下来，克隆`johns-repo`以获得`public-repo`:

```
# command issued in git-recipes/10-12 directory
$ git clone johns-repo public-repo
```

要允许推入到非裸存储库`public-repo`中，请使用以下命令更改其配置:

```
# command issued in public-repo directory
$ git config receive.denyCurrentBranch ignore
$ git config core.worktree ../
```

然后将文件`public-repo/.git/hooks/post-update.sample`重命名为`public-repo/.git/hooks/post-update`。您可以通过以下方式实现这一点:

```
# command issued in public-repo directory
$ mv .git/hooks/post-update.sample .git/hooks/post-update
```

更改`public-repo/.git/hooks/post-update`的内容，如[清单 10-4](#list4) 所示。

[***清单 10-4。***](#_list4) 公开-回购/的内容。git/hooks/更新后

```
#!/bin/sh
exec git reset --hard
```

`public-repo`的配置完成。现在转到`johns-repo`并添加遥控器:

```
# command issued in johns-repo
$ git remote add origin ../public-repo
```

在`johns-repo`中创建三个提交，使用:

```
# command issued in johns-repo
$ git simple-commit one two three
```

并用`$ git push origin master`将它们推向公开回购。

如果你现在用`$ ls`列出`public-repo`中的文件，你会注意到它的工作目录包含了`one.txt`、`two.txt`和`three.txt`文件。这证明了推送操作将`johns-repo`的最新状态转移到了`public-repo`。

它是如何工作的

由于工作目录的原因，推送到非空的远程存储库会导致问题。假设您和您的同事在主分支机构工作，并且你们都创建了一个名为`lorem.txt`的文件。如果您提交文件并将其推送到同事的存储库，那么他的工作目录会发生什么变化？是否应该执行检验？如果是这样，你的朋友可能会丢失他在`lorem.txt`中完成的工作。

第一步是允许以更新远程分支的方式进行推送。它是通过以下方式完成的:

```
$ git config receive.denyCurrentBranch ignore
```

此命令允许您推送至远程存储库。推送会将必要的对象从您的存储库上传到远程数据库，然后更新您正在推送的远程分支。远程存储库的工作目录不会受到影响。

要在远程存储库中执行签出，我们必须配置工作目录的路径。它是通过以下方式完成的:

```
$ git config core.worktree ../
```

最后一步是当有人推到`public-repo`时强制结账。这是用`post-update`钩子完成的。要使用钩子，你必须创建一个名为`public-repo/.git/hooks/post-update`的 shell 脚本。该脚本应该包含一个单独的`$ git reset --hard`命令，如[清单 10-4](#list4) 所示。

![image](images/sq.jpg) **提示**这个配方可以当作一个部署工具。`public-repo`是无人工作的仓库。这是一个可通过 HTTP 协议访问的只读存储库。食谱展示了如何通过简单的`$ git push`命令在网络上发布你的作品。

摘要

当我们讨论同步时，我们总是考虑两个存储库:本地(发出命令的那个)和远程(通过 URL 可用的那个)。为了避免反复输入 URL 的麻烦，git 可以将它存储在本地的`.git/config`文件中。使用`$ git remote`命令管理远程 URL。

git 存储库的同步是在修订图的基础上实现的。`$ git push`命令将修订从本地存储库复制到远端。当您获取时，修订会从远程存储库复制到本地存储库。在这两种情况下，数据库条目在传输过程中不会更改，它们的 SHA-1 保持不变。您可以将一组 git 存储库视为分布式数据库，其中 SHA-1 充当主键。因为 SHA-1 散列是唯一的，所以我们可以在任意存储库之间复制项目，而没有密钥冲突的风险。如果该键存在于目标数据库中，它总是被视为同一个对象。

为了解释这一点，我在我的一个存储库中创建了以下版本:

```
6c69fa3372f7099836176c8d0f123895adea58f1 Unique commit by gajdaw
```

该修订版的名称是:

```
6c69fa3372f7099836176c8d0f123895adea58f1
```

从 git 的角度来看*这个名字在整个宇宙*中是独一无二的——在所有已知的 git 仓库中。这是一个非常强有力的假设，使得存储库的同步变得容易。每个想要同步他或她的工作和我的工作的人都需要这个提交的副本。当我按下时，远端将接收到以下对象:

```
6c69fa3372f7099836176c8d0f123895adea58f1 Unique commit by gajdaw
```

这将是我的修订版的精确副本，有一个相同的 SHA-1 名字。

我们可以用另一种方式来表达同样的事实。每当您分析任何存储库中的历史时，都要查找这个:`6c69fa3372f7099836176c8d0f123895adea58f1` name。一旦你找到它，你总是可以说:*哦，我的存储库中有沃齐米耶兹·加伊达在 2013 年 9 月 6 日提交的修订，为了他的书*第十章的“总结”。没有其他同名的修订版。

一旦您理解了如何添加和删除遥控器以及如何复制修订，掌握组工作的下一步就是分支。直到现在，我们都集中在普通的地方分行。这些是你工作中使用的个人本地分支。没人知道他们。你不必向任何人咨询你在这些部门的工作。您可以创建、修改和销毁它们。

同样的规则适用于所有的存储库——不仅仅是您的。因此，我们需要既允许独立又允许合作的规则。这些规则非常简单:您的本地分支存储在以远程名称命名的单独目录中的其他存储库中。

当处于松散格式时，您的普通本地分支`a`和`b`存储在:

```
.git/refs/heads/a
.git/refs/heads/b
```

如果有人将您的存储库命名为`foo`,并带有:

```
$ git remote add foo [URL]
```

并使用`$ git fetch foo`从您的存储库中获取数据，那么您的本地分支`a`和`b`将被存储在他或她的存储库中:

```
.git/refs/remotes/foo/a
.git/refs/remotes/foo/b
```

它们不会与存储在`.git/refs/heads`中的本地分支冲突。这就是全部的诀窍。

存储在`.git/refs/remotes`中的遥控跟踪分支，如`.git/refs/remotes/foo/a`，可以简称为`foo/a`。您可以将它们用作普通的修订指针。每当你需要一个修订版的 SHA-1 时，你可以使用`foo/a`，就像你使用任何其他方法来引用提交、`HEAD`、`master∼5`、`doc^2`等等。

当您考虑同步时，三种重要的分支类型是:

*   远程分支机构
*   本地跟踪分支
*   远程跟踪分支

它们之间的关系以及`$ git commit`、`$ git fetch`、`$ git push`对它们的影响方式如图[10-29](#Fig29)所示。

![9781430261032_Fig10-29.jpg](images/9781430261032_Fig10-29.jpg)

[图 10-29](#_Fig29) 。$ git commit、$ git fetch 和$ git push 对三种类型的分支的影响

下面是[图 10-29](#Fig29) 的总结:

*   当您使用`$ git commit`提交时，您将本地跟踪分支向前移动。
*   当你用`$ git fetch`抓取时，你向前移动你的远程追踪分支。
*   当您按下`$ git push`时，您向前移动远程分支和远程跟踪分支。

始终可以使用`$ git branch -a -vv`命令检查跟踪。输出列表:

*   普通地方分行为:

    ```
    lorem    a1b2c3f Some commend
    ```

*   本地跟踪分支机构为:

    ```
    ipsum    a1b2c3f [origin/ipsum] Some comment
    ```

*   远程跟踪分支为:

    ```
    remotes/origin/dolor    a1b2c3f Some comment
    ```

`$ git branch -a -vv`命令没有列出远程分支。要列出远程分支，您必须首先用`$ git fetch`获取它们。我们可以说`$ git branch`是一个本地命令——它不执行本地和远程存储库之间的网络传输。

你将在配方 10-4 和 10-5 中找到设置和取消跟踪的具体步骤。如果你理解了每一类分支的作用，它们就非常简单。

git 的分布式角色在有和没有中央存储库的情况下展示团队工作的方法中得到了强调。为了更好地理解这个概念，请尝试在任一存储库中运行以下命令:

```
$ git fetch --no-tags https://github.com/github/GitPad master:refs/remotes/xyz/pqr
```

该命令从库`https://github.com/github/GitPad`中获取`master`分支，并将其存储在`.git/refs/remotes/xyz/pqr`文件中。该操作从 GitPad 存储库中复制修订，并将它们存储在您的`.git/objects`数据库中。如果您不想为远程存储库定义别名，您不必这样做。Git 不需要。即使没有定义远程的别名，git 也能够从一些 URL 可以访问的任何存储库中下载修订版到您的存储库中。你的仓库和 Github 上 GitPad 的仓库之间没有任何联系。远程分支主机(在 GitPad 的存储库中)和远程跟踪分支`xyz/pqr`(在您的存储库中)之间的映射由 refspec 设置:

```
master:refs/remotes/xyz/pqr
```

冒号前的部分是远程分支的名称，冒号后的部分是远程跟踪分支的名称。通过使用 URL 和 refspec，您可以从任何想要的存储库中获取任意分支。

有时候有人问我，为什么有时我们写`origin master`用空格分开，而有时我们用`/`作为分隔符。就像:

```
$ git pull origin master
$ git rebase origin/master
```

在第一个命令中，`origin`是遥控器的名称，`master`是分支的名称。这是一个普通的本地分支或本地跟踪分支。

在第二个命令中`origin/master`是远程跟踪分支的名称。上述命令的语法可以描述为:

```
$ git pull [remote] [branch]
$ git rebase [branch]
```

在第二个命令中，我们使用远程跟踪分支`origin/master`作为`[branch]`参数。